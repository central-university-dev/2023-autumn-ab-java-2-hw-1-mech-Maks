интересно, что я вообще помню из курса по алгоритмам и структурам данных из вуза)

сначала так - хэшмапа позволяет доставать элементы из себя за О(1). это, грубо говоря, набор связок типа "ключ -> значение".

чуть менее грубо говоря, берется ключ, как-то хэшируется, и из хэша получается индекс элемента в массиве. 
может быть ситуация, когда разные ключи хэшируются в один индекс, тогда есть пара способов решить проблему - 
linear probing и chaining (прошу простить за мой французский, 
но в иннополисе обучение на английском и русских терминов я не знаю).

постараюсь грубовато описать оба способа :

* linear probing - всё хранится в обычном массиве, и если появляется такой же хэш, он просто записывается в следующую 
свободную ячейку. при удалении элемента эту свободную ячейку нужно оставить заполненной каким-нибудь мусором, 
чтобы ничего не съехало)

* chaining - всё тоже хранится в обычном массиве, но если появляется такой же хэш, элемент идёт в ту же ячейку за первым
элементом, как бы образуя linked list. 

по вопросам с edu : 

1. алгоритмическая сложность доставания или закладывания элемента в хэшмапу обычно О(1). однако, это не всегда так и
может случиться такое, что хэш у всех элементов будет один и придется искать элемент в одном бакете, в таком случае 
будет worst case O(n). это если бакеты как линкед листы. в джаве, например, сейчас используются бинарные деревья, что
сокращает worst case до О(logn)

2. нет, не всегда. выше я описал, что можно обойтись обычным массивом (linear probing), но и в chaining может быть не
только linked list. в 1м пункте я как раз написал, что в 8й джаве используются бинарные деревья.

3. в хэшмапе есть load factor, который вычисляется как \frac{кол-во занятых ячеек}{кол-во всеъ ячеек}. обычно если он
больше или равен 0.75, то количество ячеек увеличивают в 2 раза, после чего происходит рехешинг - вычисление нового 
положения каждого элемента
